import argparse
import logging
import subprocess
import sys
import re
import os


GIT_VERSION_COMMAND = ["git", "describe", "--tags", "--long", "--dirty", "--always"]

GIT_VERSION_PATTERN_REGEX = r'v(?P<major>\d+)\.(?P<minor>\d+)-(?P<patch>\d+)-g(?P<short_hash>[a-f0-9]+)(?P<dirty>-dirty)?'

C_HEADER_TEMPLATE = """// ---------------------------------------------------------- //
// This file is autogenerated by gen_version.py; do not edit! //
// ---------------------------------------------------------- //

#ifndef {capitalized_filename}_H_
#define {capitalized_filename}_H_

// Implemented in version.c
extern const char * version_string;
extern const char * vcs_hash;
extern const char * build_type;

#endif  //  {capitalized_filename}_H_
"""

C_SOURCE_TEMPLATE = """// ---------------------------------------------------------- //
// This file is autogenerated by gen_version.py; do not edit! //
// ---------------------------------------------------------- //

#include "version.h"

const char * version_string = "{version_string}";
const char * vcs_hash = "{hash_string}";
const char * build_type = "{build_type}";
"""


def main(output_path, build_type):
    output = subprocess.check_output(GIT_VERSION_COMMAND, text=True)
    logging.debug(f'Raw output: {output}')
    match = re.match(GIT_VERSION_PATTERN_REGEX, output)

    version_string = "unknown"
    hash_string = ""

    if match:
        groupdict = match.groupdict()

        major = groupdict['major']
        minor = groupdict['minor']
        patch = groupdict['patch']
        short_hash = groupdict['short_hash']
        dirty = groupdict['dirty']

        dirty_string = ""
        if dirty:  # In case the dirty is None
            dirty_string = dirty

        version_string = f"{major}.{minor}.{patch}{dirty_string}"
        hash_string = short_hash

    c_header_string = C_HEADER_TEMPLATE.format(
        capitalized_filename="VERSION")
    logging.debug(f"c_header_string={c_header_string}")

    c_source_string = C_SOURCE_TEMPLATE.format(
        capitalized_filename="VERSION", version_string=version_string, hash_string=hash_string, build_type=build_type)
    logging.debug(f"c_header_string={c_source_string}")

    
    c_header_filepath = os.path.join(output_path, "version.h")
    with open(c_header_filepath, "w") as fp:
        logging.debug(f"Write to {c_header_filepath}")
        fp.write(c_header_string)

    c_source_filepath = os.path.join(output_path, "version.c")
    with open(c_source_filepath, "w") as fp:
        logging.debug(f"Write to {c_source_filepath}")
        fp.write(c_source_string)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument('-o', '--output_filepath', help="The output filepath that the C header will be written to", required=True)
    parser.add_argument('--build-type', help="CMake build type", required=True)

    parser.add_argument('-v', '--verbose', action='count', default=0)
    

    args = parser.parse_args()

    logging_levels = {0: logging.ERROR,
                      1: logging.DEBUG,
                      2: logging.INFO,
                      3: logging.WARNING,
                      4: logging.ERROR,
                      5: logging.CRITICAL}
    
    logging.basicConfig(stream=sys.stdout, level=logging_levels[args.verbose])

    main(args.output_filepath, args.build_type)
